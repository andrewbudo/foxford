# foxford
## Практикум по программированию: подготовка к региональному этапу олимпиады ##
### Ответ ###
Пусть dp[i] - количество разбиений префикса длиной i. Тогда ответ - dp[n]. Теперь чтобы посчитать dp[i] переберем где была предыдущая граница между числами. Так как число не может быть большим - переберем всего 8-9 предыдущих позиций и проверим, что число между этим разбиением и позицией i не больше данного. Пусть эта позиция q. Тогда dp[i] += dp[q]. Отдельно не забудьте проверить, что число не может начинаться с нуля.

#include<stdio.h>

#include<stdlib.h>

#include<math.h>

int main(){

int n,C,k;

int maxl,i,j;

char a[50001],c;

unsigned long long m[50001],cnt=0,powk;

scanf("%d %d %d\n",&n,&C,&k);

gets(a);

maxl=floor(log10((double)C))+1;

powk=floor(pow(10.0,k));

m[0]=1;

for(i=1;i<=n;i++){

m[i]=0;

c=a[i];

a[i]=0;

for(j=1;j<=maxl && i-j>=0;j++){

if((a[i-j]!='0' || j==1) && atoi(a+i-j)<=C){

m[i]+=m[i-j];

while(m[i]>=powk)m[i]-=powk;

}

}

a[i]=c;

}

printf("%lld",m[n]);

}

 
